## 后端技术面试38讲
## 开篇词
其实很多看起来难以坚持、让人容易放弃的事情，并不是智力、体力或者意志力的问题，更多的是方法问题。

绝大多数新技术其实都脱胎于一些既有的技术体系。

如果你能建立起这套技术思维体系，掌握这套技术体系背后的原理，那么当你接触一个新技术的时候，就可以快速把握住这个新技术的本质特征和思路方法，然后用你的技术思维体系快速推导出这个新技术是如何实现的。这个时候你其实不需要去学习这个新技术了，而是去验证这个新技术，你会去看它的文档和代码，去验证它是不是和你推导、猜测的实现方式一致，而不是去学习它怎么用了。

### 第一性原理——建立技术体系的起点

第一性原理就是让我们抓住事物最本质的特征原理，依据事物本身的规律，去推导、分析、演绎事物的各种变化规律，进而洞悉事物在各种具体场景下的表现形式，而不是追随事物的表面现象，生搬硬套各种所谓的规矩、经验和技巧，以至于在各种纷繁复杂的冲突和纠结中迷失了方向。

软件开发技术也是非常庞杂的，各种基础技术，各种编程语言，各种工具框架，各种设计模式，各种架构方法，很容易让人觉得无所适从。就算下定决心要从基础学起，上来一本厚厚的《操作系统原理》，好不容易咬牙坚持学完，回头一看，还是各种迷茫，不知道在讲什么。继续学下去，再来一套更厚的《TCP/IP 详解》，彻底耗尽了意志力和兴趣，完全放弃。

**软件的基础原理、软件的设计原理、架构的核心原理**

软件的基础原理主要是操作系统、数据结构、数据库原理等等

软件的设计原理会讲述如何设计一个强大灵活，易复用，易维护的软件

架构的核心原理围绕目前主要的互联网分布式架构以及大数据物联网架构进行剖析

其实我学几何的这种方式就是第一性原理。第一性原理是一种思维方式，一种学习方式，一种围绕事物核心推动事物正确前进的做事方式。也许这个专栏讲到的很多知识技术你已经掌握，但是这些知识技术和软件技术最基本的原理的关系你也许不甚了解。它们从何而来，又将如何构建出新的技术？如果把这些关系和原理都理解透彻了，你会发现，日常开发用到的各种技术，你不但可以随心所欲地去使用，甚至可以重新创造。

## 01丨程序运行原理：程序是如何运行又是如何崩溃的？

### 程序是如何运行起来的

不管是文本格式的代码还是可执行的代码，都被称为程序，程序是静态的，安静地呆在磁盘上，什么也干不了。

要想让程序处理数据，完成计算任务，必须把程序从外部设备加载到内存中，并在操作系统的管理调度下交给 CPU 去执行，去运行起来，才能真正发挥软件的作用，程序运行起来以后，被称作进程。

进程除了包含可执行的程序代码，还包括进程在运行期使用的内存堆空间、栈空间、供操作系统管理用的数据结构。如下图所示：

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/89c6e3bbc44cdc042e7a8bcddb3b4398.png)

堆是一块无序的内存空间，任何时候进程需要申请内存，都会从堆空间中分配，分配到的内存地址则记录在栈中。

栈是严格的一个后进先出的数据结构，同样由操作系统维护，主要用来记录函数内部的局部变量、堆空间分配的内存空间地址等。

每次函数调用，操作系统都会在栈中创建一个栈帧（stack frame）。正在执行的函数参数、局部变量、申请的内存地址等都在当前栈帧中，也就是堆栈的顶部栈帧中。如下图所示：

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/f08d6fca893da5cac926a23f1f1aa7f7.png)

真正执行的函数永远都在栈顶。而且因为栈帧是隔离的，所以不同函数可以定义相同的变量而不会发生混乱。

### 一台计算机如何同时处理数以百计的任务

如果同时有很多个进程在执行，操作系统会将 CPU 的执行时间分成很多份，进程按照某种策略轮流在 CPU 上运行。由于现代 CPU 的计算能力非常强大，虽然每个进程都只被执行了很短一个时间，但是在外部看来却好像是所有的进程都在同时执行，每个进程似乎都独占一个 CPU 执行。

进程在生命周期中，主要有三种状态，**运行**、**就绪**、**阻塞**。

- 运行：当一个进程在 CPU 上运行时，则称该进程处于运行状态。处于运行状态的进程的数目小于等于 CPU 的数目。
- 就绪：当一个进程获得了除 CPU 以外的一切所需资源，只要得到 CPU 即可运行，则称此进程处于就绪状态，就绪状态有时候也被称为等待运行状态。
- 阻塞：也称为等待或睡眠状态，当一个进程正在等待某一事件发生（例如等待 I/O 完成，等待锁……）而暂时停止运行，这时即使把 CPU 分配给进程也无法运行，故称该进程处于阻塞状态。

不同进程轮流在 CPU 上执行，每次都要进行进程间 CPU 切换，代价是非常大的，实际上，每个用户请求对应的不是一个进程，而是一个线程。线程可以理解为轻量级的进程，在进程内创建，拥有自己的线程栈，在 CPU 上进行线程切换的代价也更小。线程在运行时，和进程一样，也有三种主要状态，从逻辑上看，进程的主要概念都可以套用到线程上。

### 系统为什么会变慢，为什么会崩溃

启动多线程，为每个用户请求分配一个处理线程的工作是在 web 容器中完成的，比如常用的 Tomcat 容器。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/d40cc1e9a2a5ce3913670743f0543b9a.png)

真正完成最终计算的，是 CPU、内存等服务器硬件，操作系统将这些硬件进行分时（CPU）、分片（内存）管理，虚拟化成一个独享资源让 JVM 进程在其上运行。

不管你是否有意识，你开发的 web 程序都是被多线程执行的，web 开发天然就是多线程开发。

CPU 以线程为单位进行分时共享执行，可以想象代码被加载到内存空间后，有多个线程在这些代码上执行，这些线程从逻辑上看，是同时在运行的，每个线程有自己的线程栈，所有的线程栈都是完全隔离的，也就是每个方法的参数和方法内的局部变量都是隔离的，一个线程无法访问到其他线程的栈内数据。

但是当某些代码修改内存堆里的数据的时候，如果有多个线程在同时执行，就可能会出现同时修改数据的情况，这就是人们常说的**线程安全**问题。

多个线程访问共享资源的这段代码被称为**临界区**，解决线程安全问题的主要方法是使用锁，将临界区的代码加锁，只有获得锁的线程才能执行临界区代码。

```
lock.lock();  //线程获得锁
i++;  //临界区代码，i位于堆中
lock.unlock();  //线程释放锁
```

如果当前线程执行到第一行，获得锁的代码的时候，锁已经被其他线程获取并没有释放，那么这个线程就会进入阻塞状态，等待前面释放锁的线程将自己唤醒重新获得锁。

锁会引起线程阻塞，如果有很多线程同时在运行，那么就会出现线程排队等待锁的情况，线程无法并行执行，系统响应速度就会变慢。此外 I/O 操作也会引起阻塞，对数据库连接的获取也可能会引起阻塞。目前典型的 web 应用都是基于 RDBMS 关系数据库的，web 应用要想访问数据库，必须获得数据库连接，而受数据库资源限制，每个 web 应用能建立的数据库的连接是有限的，如果并发线程数超过了连接数，那么就会有部分线程无法获得连接而进入阻塞，等待其他线程释放连接后才能访问数据库，并发的线程数越多，等待连接的时间也越多，从 web 请求者角度看，响应时间变长，**系统变慢**。

被阻塞的线程越多，占据的系统资源也越多，这些被阻塞的线程既不能继续执行，也不能释放当前已经占据的资源，在系统中一边等待一边消耗资源，如果阻塞的线程数超过了某个系统资源的极限，就会导致系统宕机，**应用崩溃**。

解决系统因高并发而导致的响应变慢、应用崩溃的主要手段是使用**分布式系统架构**，用更多的服务器构成一个集群，以便共同处理用户的并发请求，保证每台服务器的并发负载不会太高。此外必要时还需要在请求入口处进行**限流**，减小系统的并发请求数；在应用内进行业务**降级**，减小线程的资源消耗。

## 02丨数据结构原理：Hash表的时间复杂度为什么是O(1)？

此后十年间，我用这个问题面试了大约上千人，这些面试经历让我更加坚定了一个想法：这个问题就是候选人技术水平的一个分水岭，是证明一个技术人员是否具有必备专业技能和技术悟性的一个门槛。这个槛过不去是不可接受的。

为什么呢？我很难相信，如果基本的数据结构没有掌握好，如何能开发好一个稍微复杂一点的程序？

### 数组

数组是最常用的数据结构，创建数组必须要内存中一块连续的空间，并且数组中必须存放相同的数据类型。

随机快速读写是数组的一个重要特性，但是要随机访问数据，必须知道数据在数组中的下标。如果我们只是知道数据的值，想要在数组中找到这个值，那么就只能遍历整个数组，时间复杂度为 O(N)。

### 链表

不同于数组必须要连续的内存空间，链表可以使用零散的内存空间存储数据。不过，因为链表在内存中的数据不是连续的，所以链表中的每个数据元素都必须包含一个指向下一个数据元素的内存地址指针。

因为链表是不连续存储的，要想在链表中查找一个数据，只能遍历链表，所以链表的查找复杂度总是 O(N)。

但是正因为链表是不连续存储的，所以在链表中插入或者删除一个数据是非常容易的，只要找到要插入（删除）的位置，修改链表指针就可以了。

相比在链表中轻易插入、删除一个元素这种简单的操作，如果我们要想在数组中插入、删除一个数据，就会改变数组连续内存空间的大小，需要重新分配内存空间，这样要复杂得多。

### Hash 表

Hash 表的物理存储其实是一个数组，如果我们能够根据 Key 计算出数组下标，那么就可以快速在数组中查找到需要的 Key 和 Value。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/e2d3191b087d902980595aeb1be79dcb.png)

上图这个例子中，Key 是字符串 abc，Value 是字符串 hello。我们先计算 Key 的哈希值，得到 101 这样一个整型值。然后用 101 对 8 取模，这个 8 是哈希表数组的长度。

### 但是如果不同的 Key 计算出来的数组下标相同怎么办？

HashCode101 对 8 取模余数是 5，HashCode109 对 8 取模余数还是 5，也就是说，不同的 Key 有可能计算得到相同的数组下标，这就是所谓的 Hash 冲突，解决 Hash 冲突常用的方法是链表法。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/ea89bec385ebfe5c03b306deead03c9a.png)

因为有 Hash 冲突的存在，所以“Hash 表的时间复杂度为什么是 O(1)？”这句话并不严谨，极端情况下，如果所有 Key 的数组下标都冲突，那么 Hash 表就退化为一条链表，查询的时间复杂度是 O(N)。但是作为一个面试题，“Hash 表的时间复杂度为什么是 O(1)”是没有问题的。

### 栈

栈就是在线性表的基础上加了这样的操作限制条件：后面添加的数据，在删除的时候必须先删除，即通常所说的“后进先出”。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/85752adc1fc26453e2236f0a8b01c081.png)

我们上篇提到的程序运行过程中，方法的调用需要用栈来管理每个方法的工作区，这样，不管方法如何嵌套调用，栈顶元素始终是当前正在执行的方法的工作区。

### 队列

队列也是一种操作受限的线性表，栈是后进先出，而队列是先进先出。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/a396ab50312b5faa29c7b93f6ad4b7a5.png)

现实中也是如此，超市在货架上摆放食品的时候，其实是按照队列摆放的，而不是堆栈摆放的。工作人员在上架新食品的时候，总是把新食品摆在后面，使食品成为一个队列，以便让以前上架的食品被尽快卖出。

### 树

数组、链表、栈、队列都是线性表，也就是每个数据元素都只有一个前驱，一个后继。而树则是非线性表，树是这样的。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/88906ad45504ae3d195dadc9b7a455cd.png)

软件开发中，也有很多地方用到树，比如我们要开发一个 OA 系统，部门的组织结构就是一棵树；我们编写的程序在编译的时候，第一步就是将程序代码生成抽象语法树。传统上树的遍历使用递归的方式，而我个人更喜欢用设计模式中的组合模式进行树的遍历。

## 03丨Java虚拟机原理：JVM为什么被称为机器（machine）？

暂略

## 04丨网络编程原理：一个字符的互联网之旅

了解网络通信原理，了解互联网应用如何跨越庞大的网络构建起来，对我们开发一个互联网应用系统很有帮助，对我们解决系统运行过程中各种因为网络通信而出现的各种问题更有帮助。

### DNS

构成互联网 Internet 的最基本的网络协议就是互联网协议 Internet Protocol，简称 IP 协议。IP 协议里面最重要的部分是 IP 地址，各种计算机设备之间能够互相通信，首先要能够找到彼此，IP 地址就是互联网的地址标识。

事实上这个 IP 地址是通过 DNS 域名解析服务器得到的。当我们打开淘宝 App 的时候，淘宝要把 App 首页加载进来，这时候就需要连接域名服务器进行域名解析，将 xxx.taobao.com 这样的域名解析为一个 IP 地址，然后连接目标服务器。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/b66ab4aad74e047b671f59d9172c9f9a.png)

### CDN

事实上 DNS 解析出来的 IP 地址，并不一定是淘宝数据中心的 IP 地址，也可能是淘宝 CDN 服务器的 IP 地址。

CDN 是内容分发网络 Content Delivery Network 的缩写。

为了提高用户请求访问的速度，也为了降低数据中心的负载压力，淘宝会在全国各地各个主要的运营服务商的接入机房中部署一些缓存服务器，缓存那些静态的图片、资源文件等，这些缓存服务器构成了淘宝的 CDN。

如果用户请求的数据数据是静态的资源，这些资源的 URL 通常以 image.taobao.com 之类的二级域名进行标识，域名解析的时候就会解析为淘宝 CDN 的 IP 地址，请求先被 CDN 处理，如果 CDN 中有需要的静态文件，就直接返回，如果没有，CDN 会将请求发送到淘宝的数据中心，CDN 从淘宝数据中心获得静态文件后，一方面缓存在自己的服务器上，一方面将数据返回给用户的 App。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/2da7c834bfadb8aee3325cea78fbd7a4.png)

### HTTP

不管发送到 CDN 还是数据中心，App 请求都会以 HTTP 协议发送。

HTTP 是一个应用层协议，当我们进行网络通信编程的时候，通常需要关注两方面的内容，一方面是应用层的通信协议，主要是我们通信的数据如何编码，既能使网络传输过去的数据携带必要的信息，又使通信的两方都能正确识别这些数据，即通信双方应用程序需要约定一个数据编码协议。另一方面就是网络底层通信协议，即如何为网络上需要通信的两个节点建立连接完成数据传输，目前互联网应用中最主要的就是 TCP 协议。

在 TCP 传输层协议层面，就是保证建立通信两方的稳定通信连接，将一方的数据以 bit 流的方式源源不断地发送到另一方，至于这些数据代表什么意思，哪里是两次请求的分界点，TCP 协议统统不管，需要应用层面自己解决。如果我们基于 TCP 协议自己开发应用程序，就必须解决这些问题。而互联网应用需要在全球范围为用户提供服务，将全球的应用和全球的用户联系在一起，需要一个统一的应用层协议，这个协议就是 HTTP 协议。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/79d09c6e3cd898f29b7432af5de81a50.png)

HTTP 请求如果是 GET 方法，那么就只有请求头；如果是 POST 方法，在请求头之后还有一个 body 部分，包含请求提交的内容，HTTP 会在请求头的 Content-Length 参数声明 body 的长度。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/4e396c4b95f22000b5cdd4d6ddc38192.png)

这是 HTTP 响应头的例子，响应头和请求头一样包含各种参数，而 status 状态码声明响应状态，状态码是 200，表示响应正常。

### TCP

应用程序使用操作系统的 socket 接口进行网络编程，socket 里封装了 TCP 协议。应用程序通过 socket 接口使用 TCP 协议完成网络编程，socket 或者 TCP 在应用程序看就是一个底层通信协议，事实上，TCP 仅仅是一个传输层协议，在传输层协议之下，还有网络层协议，网络层协议之下还有数据链路层协议，数据链路层协议之下还有物理层协议。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/ab0f73a9e8aef340dffa7fd64f299d9a.png)

传输层协议 TCP 和网络层协议 IP 共同构成 TCP/IP 协议栈，成为互联网应用开发最主要的通信协议。OSI 开放系统互联模型将网络协议定义了 7 层，TCP/IP 协议栈将 OSI 顶部三层协议应用层、表示层、会话层合并为一个应用层，HTTP 协议就是 TCP/IP 协议栈中的应用层协议。

**物理层**负责数据的物理传输，计算机输入输出的只能是 0 1 这样的二进制数据，但是在真正的通信线路里有光纤、电缆、无线各种设备。光信号和电信号，以及无线电磁信号在物理上是完全不同的，如何让这些不同的设备能够理解、处理相同的二进制数据，这就是物理层要解决的问题。

**数据链路层**就是将数据进行封装后交给物理层进行传输，主要就是将数据封装成数据帧，以帧为单位通过物理层进行通信，有了帧，就可以在帧上进行数据校验，进行流量控制。数据链路层会定义帧的大小，这个大小也被称为最大传输单元。

**网络层**的数据需要交给链路层进行处理，而链路层帧的大小定义了最大传输单元，网络层的 IP 数据包必须要小于最大传输单元才能进行网络传输，这个数据包也有一个 IP 头，主要包括的就是发送者和接受者的 IP 地址。

**IP 协议不是一个可靠的通信协议**，并不会确保数据一定送达。**要保证通信的稳定可靠，需要传输层协议 TCP**。TCP 协议在传输正式数据前，会先建立连接，这就是著名的 TCP 三次握手。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/22998c116366030bfce5ef4043579a2b.png)

如果我们以 POST 方法提交一个搜索请求给淘宝服务器，那么最终在数据链路层构建出来的数据帧大概是这个样子，这里假设 IP 数据包的大小没有超过链路层的最大传输单元。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/2ef260e20f190fed1d03febdea09378d.png)

LB（负载均衡）

搜索请求到达数据中心的时候，首先到达的是搜索服务器集群的负载均衡服务器，也就是说，DNS 解析出来的是负载均衡服务器的 IP 地址。然后，由负载均衡服务器将请求分发到搜索服务器集群中的某台服务器上。

负载均衡服务器的实现手段有很多种，淘宝这样规模的应用，通常使用 Linux 内核支持的链路层负载均衡。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/e0cbd3c93b67ed042c786862ede00f46.png)

这种负载均衡模式也叫直接路由模式，在负载均衡服务器的 Linux 操作系统内核拿到数据包后，直接修改数据帧中的 mac 地址，将其修改为搜索服务器集群中某个服务器的 mac 地址，然后将数据重新发送回服务器集群所在的局域网，这个数据帧就会被某个真实的搜索服务器接收到。

## 05丨文件系统原理：如何用1分钟遍历一个100TB的文件？

### 硬盘

硬盘是一种可持久保存、多次读写数据的存储介质。硬盘的形式主要两种，一种是机械式硬盘，一种是固态硬盘。

### 文件系统

作为应用程序开发者，我们不需要直接操作硬盘，而是通过操作系统，以文件的方式对硬盘上的数据进行读写访问。文件系统将硬盘空间以块为单位进行划分，每个文件占据若干个块，然后再通过一个文件控制块 FCB 记录每个文件占据的硬盘数据块。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/fd01187215f71c82a0531c98d39442fc.png)

这个文件控制块在 Linux 操作系统中就是 inode，要想访问文件，就必须获得文件的 inode 信息，在 inode 中查找文件数据块索引表，根据索引中记录的硬盘地址信息访问硬盘，读写数据。

inode 中记录着文件权限、所有者、修改时间和文件大小等文件属性信息，以及文件数据块硬盘地址索引。inode 是固定结构的，能够记录的硬盘地址索引数也是固定的，只有 15 个索引。其中前 12 个索引直接记录数据块地址，第 13 个索引记录索引地址，也就是说，索引块指向的硬盘数据块并不直接记录文件数据，而是记录文件数据块的索引表，每个索引表可以记录 256 个索引；第 14 个索引记录二级索引地址，第 15 个索引记录三级索引地址，如下图：

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/30e8aaa432b315e5b16a06a787ff0437.jpg)

这样，每个 inode 最多可以存储 12+256+256*256+256*256*256 个数据块，如果每个数据块的大小为 4k，也就是单个文件最大不超过 70G，而且即使可以扩大数据块大小，文件大小也要受单个硬盘容量的限制。这样的话，对于我们开头提出的一分钟完成 100T 大文件的遍历，Linux 文件系统是无法完成的。

### RAID

RAID，即独立硬盘冗余阵列，将多块硬盘通过硬件 RAID 卡或者软件 RAID 的方案管理起来，使其共同对外提供服务

根据硬盘组织和使用方式不同，常用 RAID 有五种，分别是 RAID 0、RAID 1、RAID 10、RAID 5 和 RAID 6。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/327bcad9c707d4256c98ffeb88f76f0b.jpg)

到较好的硬盘利用率，也能得到很好的读写速度，同时还能保证较好的数据可用性。使用 RAID 5 的文件系统比简单的文件系统文件容量和读写速度都提高了 N-1 倍，但是一台服务器上能插入的硬盘数量是有限的，通常是 8 块，也就是文件读写速度和存储容量提高了 7 倍。

### 分布式文件系统

我们再回过头看下 Linux 的文件系统：文件的基本信息，也就是文件元信息记录在文件控制块 inode 中，文件的数据记录在硬盘的数据块中，inode 通过索引记录数据块的地址，读写文件的时候，查询 inode 中的索引记录得到数据块的硬盘地址，然后访问数据。

如果将数据块的地址改成分布式服务器的地址呢？也就是查询得到的数据块地址不只是本机的硬盘地址，还可以是其他服务器的地址，那么文件的存储容量就将是整个分布式服务器集群的硬盘容量，这样还可以在不同的服务器上同时并行读取文件的数据块，文件访问速度也将极大的加快。

我们以 Hadoop 分布式文件系统 HDFS 为例，看下分布式文件系统的具体架构设计。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/a67d5e95c3ed1f6261649ae346e9aaeb.png)

DataNode 负责文件数据的存储和读写操作，HDFS 将文件数据分割成若干数据块（Block），每个 DataNode 存储一部分数据块，这样文件就分布存储在整个 HDFS 服务器集群中。应用程序客户端（Client）可以并行对这些数据块进行访问，从而使得 HDFS 可以在服务器集群规模上实现数据并行访问，极大地提高了访问速度。在实践中，HDFS 集群的 DataNode 服务器会有很多台，一般在几百台到几千台这样的规模，每台服务器配有数块硬盘，整个集群的存储容量大概在几 PB 到数百 PB。

NameNode 负责整个分布式文件系统的元数据（MetaData）管理，也就是文件路径名、访问权限、数据块的 ID 以及存储位置等信息，相当于 Linux 系统中 inode 的角色。HDFS 为了保证数据的高可用，会将一个数据块复制为多份（缺省情况为 3 份），并将多份相同的数据块存储在不同的服务器上，甚至不同的机架上。这样当有硬盘损坏，或者某个 DataNode 服务器宕机，甚至某个交换机宕机，导致其存储的数据块不能访问的时候，客户端会查找其备份的数据块进行访问。

有了 HDFS，可以实现单一文件存储几百 T 的数据，再配合大数据计算框架 MapReduce 或者 Spark，可以对这个文件的数据块进行并发计算。也可以使用 Impala 这样的 SQL 引擎对这个文件进行结构化查询，在数千台服务器上并发遍历 100T 的数据，1 分钟都是绰绰有余的。

## 06丨数据库原理：为什么PrepareStatement性能更好更安全？

### 数据库架构与 SQL 执行过程

关系数据库系统 RDBMS 有很多种，但是这些关系数据库的架构基本上差不多，包括支持 SQL 语法的 Hadoop 大数据仓库，也基本上都是相似的架构。一个 SQL 提交到数据库，经过连接器将 SQL 语句交给语法分析器，生成一个抽象语法树 AST；AST 经过语义分析与优化器，进行语义优化，使计算过程和需要获取的中间数据尽可能少，然后得到数据库执行计划；执行计划提交给具体的执行引擎进行计算，将结果通过连接器再返回给应用程序。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/faec977f77e80f6d116e40735cf21e17.png)

### 使用 PrepareStatement 执行 SQL 的好处

一个是 PrepareStatement 会预先提交带占位符的 SQL 到数据库进行预处理，提前生成执行计划，当给定占位符参数，真正执行 SQL 的时候，执行引擎可以直接执行，效率更好一点。

另一个好处则更为重要，PrepareStatement 可以防止 SQL 注入攻击。

### 数据库文件存储原理

为什么索引能加快查询速度呢？

数据库索引使用 B+ 树，我们先看下 B+ 树这种数据结构。B+ 树是一种 N 叉排序树，树的每个节点包含 N 个数据，这些数据按顺序排好，两个数据之间是一个指向子节点的指针，而子节点的数据则在这两个数据大小之间。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/f45e421a8e5172b9bc9fd1709fc98456.png)

B+ 树的节点存储在磁盘上，每个节点存储 1000 多个数据，这样树的深度最多只要 4 层，就可存储数亿的数据。如果将树的根节点缓存在内存中，则最多只需要三次磁盘访问就可以检索到需要的索引数据。

B+ 树只是加快了索引的检索速度，如何通过索引加快数据库记录的查询速度呢？

数据库索引有两种，一种是聚簇索引（Clustered Index），**聚簇索引的数据库记录和索引存储在一起**，上面这张图就是聚簇索引的示意图，在叶子节点，索引 1 和记录行 r1 存储在一起，查找到索引就是查找到数据库记录。像 MySQL 数据库的主键就是聚簇索引，主键 ID 和所在的记录行存储在一起。MySQL 的数据库文件实际上是以主键作为中间节点，行记录作为叶子节点的一颗 B+ 树。

另一种数据库索引是非聚簇索引（Non-clustered Index），**非聚簇索引在叶子节点记录的就不是数据行记录，而是聚簇索引，也就是主键**，如下图。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/580f1aa37880751f81e89d4a53ae3f51.png)

通过 B+ 树在叶子节点找到非聚簇索引 a，和索引 a 在一起存储的是主键 1，再根据主键 1 通过主键（聚簇）索引就可以找到对应的记录 r1，这种通过非聚簇索引找到主键索引，再通过主键索引找到行记录的过程也被称作回表。

所以通过索引，可以快速查询到需要的记录，而如果要查询的字段上没有建索引，就只能扫描整张表了，查询速度就会慢很多。

## 07丨编程语言原理：面向对象编程是编程的终极形态吗？

略

## 08丨软件设计的方法论：软件为什么要建模？

略

## 09丨软件设计实践：如何使用UML完成一个设计文档？

略

## 10 | 软件设计的目的：糟糕的程序员比优秀的程序员差在哪里？

程序员的好坏，一方面体现在编程能力上，比如并不是每个程序员都有编写一个编译器程序的能力；另一方面，体现在程序设计方面，即使在没有太多编程技能要求的领域下，比如开发一个订单管理模块，只要需求明确，具有一定的编程经验，大家都能开发出这样一个程序，但优秀的程序员和糟糕的程序员之间，依然有巨大的差别。

在软件设计开发这个领域，好的设计和坏的设计最大的差别就体现在应对需求变更的能力上。**而好的程序员和差的程序员的一个重要区别，就是对待需求变更的态度。**差的程序员害怕需求变更，因为每次针对需求变更而开发的代码都会导致无尽的 bug；好的程序员则欢迎需求变更，因为他们一开始就针对需求变更进行了软件设计，如果没有需求变更，他们优秀的设计就没有了用武之地，产生一拳落空的感觉。这两种不同态度的背后，是设计能力的差异。

## 11丨软件设计的开闭原则：如何不修改代码却能实现需求变更？开闭原则

### 开闭原则

软件实体（模块、类、函数等等）应该对扩展是开放的，对修改是关闭的。

对扩展是开放的，意味着软件实体的行为是可扩展的，当需求变更的时候，可以对模块进行扩展，使其满足需求变更的要求。

对修改是关闭的，意味着当对软件实体进行扩展的时候，不需要改动当前的软件实体；不需要修改代码；对于已经完成的类文件不需要重新编辑；对于已经编译打包好的模块，不需要再重新编译。

通俗的说就是，**软件功能可以扩展，但是软件实体不可以被修改。**

**当我们在代码中看到 else 或者 switch/case 关键字的时候，基本可以判断违反开闭原则了。**

## 12 | 软件设计的依赖倒置原则：如何不依赖代码却可以复用它的功能？

依赖倒置原则是这样的：

- 高层模块不应该依赖低层模块，二者都应该依赖抽象。
- 抽象不应该依赖具体实现，具体实现应该依赖抽象。

### 那么这种高层模块依赖低层模块的分层依赖方式有什么缺点呢？

一是维护困难，高层模块通常是业务逻辑和策略模型，是一个软件的核心所在。正是高层模块使一个软件区别于其他软件，而低层模块则更多的是技术细节。如果高层模块依赖低层模块，那么就是业务逻辑依赖技术细节，技术细节的改变将影响到业务逻辑，使业务逻辑也不得不做出改变。因为技术细节的改变而影响业务代码的改变，这是不合理的。

二是复用困难，通常越是高层模块，复用的价值越高。但如果高层模块依赖低层模块，那么对高层模块的依赖将会导致对底层模块的连带依赖，使复用变得困难。

### 依赖倒置的关键是接口所有权的倒置

这是我们习惯上的层次依赖示例，策略层依赖方法层，方法层依赖工具层。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/4642c03ba5b5f36baac550326e0943df.png)

这样分层依赖的一个潜在问题是，策略层对方法层和工具层是传递依赖的，下面两层的任何改动都会导致策略层的改动，这种传递依赖导致的级联改动可能会导致软件维护过程非常糟糕。

解决办法是利用依赖倒置的设计原则，每个高层模块都为它所需要的服务声明一个抽象接口，而低层模块则实现这些抽象接口，高层模块通过抽象接口使用低层模块。

![img](05_%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2.assets/80d012cfab510eb1d4e7a57ab2f6277e.png)

这样，高层模块就不需要直接依赖低层模块，而变成了低层模块依赖高层模块定义的抽象接口，从而实现了依赖倒置，解决了策略层、方法层、工具层的传递依赖问题。

所以依赖倒置原则也被称为好莱坞原则：Don’t call me，I will call you. 即不要来调用我，我会调用你。

Tomcat、Spring 都是基于这一原则设计出来的，应用程序不需要调用 Tomcat 或者 Spring 这样的框架，而是框架调用应用程序。**而实现这一特性的前提就是应用程序必须实现框架的接口规范**，比如实现 Servlet 接口。

## 13丨软件设计的里氏替换原则：正方形可以继承长方形吗？

面向对象编程语言有三大特性：封装、继承、多态。

通俗地说，接口（抽象类）的多个实现就是多态。

**多态**可以让程序在编程时面向接口进行编程，在运行期绑定具体类，从而使得类之间不需要直接耦合，就可以关联组合，构成一个更强大的整体对外服务。**绝大多数设计模式其实都是利用多态的特性玩的把戏**。

**封装**是面向对象语言提供的特性，将属性和方法封装在类里面。

**继承**似乎比多态和封装要简单一些，但实践中，继承的误用也很常见。

### 里氏替换原则

若对每个类型 T1 的对象 o1，都存在一个类型 T2 的对象 o2，使得在所有针对 T2 编写的程序 P 中，用 o1 替换 o2 后，程序 P 的行为功能不变，则 T1 是 T2 的子类型。

通俗地说就是：**子类型必须能够替换掉它们的基类型**。

再稍微详细点说，就是：程序中，所有使用基类的地方，都应该可以用子类代替。

### 子类不能比父类更严格

当子类继承父类的时候，根据里氏替换原则，使用者可以在使用父类的地方使用子类替换，那么从契约的角度，子类的契约就不能比父类更严格，否则使用者在用子类替换父类的时候，就会因为更严格的契约而失败。

在类的继承中，如果父类方法的访问控制是 protected，那么子类 override 这个方法的时候，可以改成是 public，但是不能改成 private。因为 private 的访问控制比 protected 更严格，能使用父类 protected 方法的地方，不能用子类的 private 方法替换，否则就是违反里氏替换原则的。相反，如果子类方法的访问控制改成 public 就没问题，即子类可以有比父类更宽松的契约。同样，子类 override 父类方法的时候，不能将父类的 public 方法改成 protected，否则会出现编译错误。

通常说来，子类比父类的契约更严格，都是违反里氏替换原则的。

子类不应该比父类更严格，这个原则看起来既合理又简单，但是在实际中，如果你不严谨地审视自己的设计，是很可能违背里氏替换原则的。

实践中，当你继承一个父类仅仅是为了复用父类中的方法的时候，那么很有可能你离错误的继承已经不远了。

一个类如果不是为了被继承而设计，那么最好就不要继承它。粗暴一点地说，如果不是抽象类或者接口，最好不要继承它。

如果你确实需要使用一个类的方法，最好的办法是组合这个类而不是继承这个类，这就是人们通常说的组合优于继承。

## 14 | 软件设计的单一职责原则：为什么说一个类文件打开最好不要超过一屏？

